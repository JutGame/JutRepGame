workflows:
  unity-ios-release-publish:
    name: Unity iOS Release + Publish (unsigned archive ‚Üí automatic export for app target)
    instance_type: mac_mini_m2
    max_build_duration: 120

    environment:
      ios_signing:
        distribution_type: app_store
        bundle_identifier: com.Aimjute.Jute
      vars:
        UNITY_VERSION: "6000.0.47f1"
        UNITY_CHANGESET: "2ad1ed33fd3b"
        BUILD_SCRIPT: "BuildiOS"
        PROJECT_PATH: "Game"
        UNITY_IOS_DIR: "iOSBuild"
        XCODE_PROJECT: "Unity-iPhone.xcodeproj"
        XCODE_SCHEME: "Unity-iPhone"
        BUNDLE_ID_OVERRIDE: "com.Aimjute.Jute"
      groups:
        - unity
        - signing
        - app_store_connect

    scripts:
      - name: Use Xcode 16.4
        script: |
          set -euxo pipefail
          sudo xcode-select --switch /Applications/Xcode-16.4.app/Contents/Developer
          xcodebuild -version

      - name: Init shared env file
        script: |
          set -euo pipefail
          CM_ENV_FILE="${CM_ENV:-$CM_BUILD_DIR/.cm_env}"
          mkdir -p "$CM_BUILD_DIR"
          : > "$CM_ENV_FILE"
          export CM_ENV="$CM_ENV_FILE"
          echo "‚úÖ CM_ENV initialized at $CM_ENV"

      - name: Ensure Unity Hub app exists
        script: |
          set -euo pipefail
          if [ ! -d "/Applications/Unity Hub.app" ]; then
            echo "‚Üí Installing Unity Hub‚Ä¶"
            HUB_DMG_URL="https://public-cdn.cloud.unity3d.com/hub/prod/UnityHubSetup.dmg"
            curl -L -o UnityHub.dmg "$HUB_DMG_URL"
            hdiutil attach UnityHub.dmg -nobrowse -quiet
            cp -R "/Volumes/Unity Hub/Unity Hub.app" /Applications/
            hdiutil detach "/Volumes/Unity Hub" -quiet || true
          fi
          echo "‚úÖ Unity Hub present"

      - name: Preflight check required secrets
        script: |
          set -euo pipefail
          missing=0
          need_vars=(UNITY_EMAIL UNITY_PASSWORD PROVISIONING_PROFILE CERTIFICATE_P12 CERTIFICATE_PASSWORD APP_STORE_CONNECT_ISSUER_ID APP_STORE_CONNECT_KEY_IDENTIFIER APP_STORE_CONNECT_PRIVATE_KEY)
          for v in "${need_vars[@]}"; do
            if [ -z "${!v:-}" ]; then echo "‚ùå Missing $v"; missing=1; fi
          done
          [ $missing -eq 0 ] || exit 1
          echo "‚úÖ Secrets check passed"

      - name: Install Unity via Headless Hub (no SIGPIPE)
        script: |
          set -euo pipefail
          HUB="/Applications/Unity Hub.app/Contents/MacOS/Unity Hub"
          echo "‚Üí Install editor ${UNITY_VERSION} (arm64) + iOS module"
          (yes Y | "$HUB" -- --headless install --version "$UNITY_VERSION" --changeset "$UNITY_CHANGESET" -a arm64) || true
          (yes Y | "$HUB" -- --headless install-modules --version "$UNITY_VERSION" -m ios -a arm64) || true
          UNITY_BIN="/Applications/Unity/Hub/Editor/${UNITY_VERSION}/Unity.app/Contents/MacOS/Unity"
          [ -x "$UNITY_BIN" ] || { echo "‚ùå Unity not found at $UNITY_BIN"; exit 1; }
          echo "UNITY_BIN=$UNITY_BIN" >> "$CM_ENV"
          echo "‚úÖ Unity installed"

      - name: Activate Unity License (non-fatal)
        script: |
          set -euo pipefail
          source "$CM_ENV"
          echo "üîê Activating Unity license (non-fatal)‚Ä¶"
          "$UNITY_BIN" -batchmode -quit \
            -serial "${UNITY_SERIAL:-}" \
            -username "${UNITY_EMAIL:-}" \
            -password "${UNITY_PASSWORD:-}" \
            -logFile /tmp/unity_activation.log || true
          tail -n +1 /tmp/unity_activation.log || true
          echo "‚úÖ License step finished"

      - name: Ensure DOTween link.xml (anti-stripping)
        script: |
          set -euo pipefail
          PROJECT_FULL_PATH="$CM_BUILD_DIR/$PROJECT_PATH"
          RES_DIR="$PROJECT_FULL_PATH/Assets/Resources"
          mkdir -p "$RES_DIR"
          LINK_FILE="$RES_DIR/link.xml"
          if [ ! -f "$LINK_FILE" ]; then
            cat > "$LINK_FILE" <<'EOF'
          <linker>
            <assembly fullname="DOTween" preserve="all" />
            <assembly fullname="DOTween.Modules" preserve="all" />
          </linker>
          EOF
            echo "‚úÖ Created $LINK_FILE"
          else
            echo "‚ÑπÔ∏è link.xml already exists, skipping."
          fi

      - name: Clean iOS build folder
        script: |
          set -euo pipefail
          IOS_DIR="$CM_BUILD_DIR/$PROJECT_PATH/$UNITY_IOS_DIR"
          rm -rf "$IOS_DIR"
          mkdir -p "$IOS_DIR"
          echo "‚úÖ Clean iOS folder ready."

      - name: Generate Xcode Project
        script: |
          set -euo pipefail
          source "$CM_ENV"
          PROJECT_FULL_PATH="$CM_BUILD_DIR/$PROJECT_PATH"
          echo "üöß Generating Xcode project‚Ä¶"
          "$UNITY_BIN" -batchmode -quit \
            -projectPath "$PROJECT_FULL_PATH" \
            -executeMethod "BuildScript.$BUILD_SCRIPT" \
            -logFile /tmp/unity_build.log
          tail -n 200 /tmp/unity_build.log || true
          if grep -qE "Build completed with a result of 'Succeeded'|Build succeeded" /tmp/unity_build.log; then
            echo "‚úÖ Unity build succeeded"
          else
            echo "‚ùå Unity build failed"; exit 1
          fi

      - name: Validate generated Xcode project
        script: |
          set -euo pipefail
          IOS_DIR="$CM_BUILD_DIR/$PROJECT_PATH/$UNITY_IOS_DIR"
          PBXPROJ="$(find "$IOS_DIR" -name 'project.pbxproj' | head -n 1)"
          [ -f "$PBXPROJ" ] || { echo "‚ùå project.pbxproj not found"; exit 1; }
          plutil -lint "$PBXPROJ" || true
          echo "‚úÖ pbxproj is present."

      - name: Strip signing from pbxproj (targets + embed phases)
        script: |
          set -euo pipefail
          IOS_DIR="$CM_BUILD_DIR/$PROJECT_PATH/$UNITY_IOS_DIR"
          PBXPROJ="$(find "$IOS_DIR" -name 'project.pbxproj' | head -n 1)"
          [ -f "$PBXPROJ" ] || { echo "‚ùå project.pbxproj not found"; exit 1; }

          # 1) –ü–µ—Ä–µ–≤–æ–¥–∏–º –Ω–∞ Automatic –∏ —á–∏—Å—Ç–∏–º —è–≤–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª–∏
          perl -0777 -pe 's/^[ \t]*PROVISIONING_PROFILE(?:_SPECIFIER)?(?:_APP)?[^\n]*\n//mg' -i "$PBXPROJ"
          perl -0777 -pe 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' -i "$PBXPROJ"
          perl -0777 -pe 's/ProvisioningStyle = Manual;/ProvisioningStyle = Automatic;/g' -i "$PBXPROJ"

          # 2) –£–±–∏—Ä–∞–µ–º entitlements –∏–∑ UnityFramework
          perl -0777 -pe 's/^[ \t]*CODE_SIGN_ENTITLEMENTS = .*UnityFramework.*\n//mg' -i "$PBXPROJ"

          # 3) –£–±–∏—Ä–∞–µ–º CodeSignOnCopy —É Embed Frameworks
          perl -0777 -pe 's/ATTRIBUTES = \((?:[^)]*?)CodeSignOnCopy(?:[^)]*?)\);/ATTRIBUTES = (RemoveHeadersOnCopy, );/g' -i "$PBXPROJ"

          echo "üîé Verifying cleanup‚Ä¶"
          if grep -nE 'ProvisioningStyle = Manual|PROVISIONING_PROFILE' "$PBXPROJ"; then
            echo "‚ùå Still has manual signing in pbxproj"; exit 1
          fi
          echo "‚úÖ pbxproj cleaned"

      - name: Prepare signing assets (keychain + profile + p12)
        script: |
          set -euo pipefail
          source "$CM_ENV"
          IOS_DIR="$CM_BUILD_DIR/$PROJECT_PATH/$UNITY_IOS_DIR"
          PLIST="$IOS_DIR/Info.plist"

          # Bundle ID (–¥–ª—è –≥–ª–∞–≤–Ω–æ–≥–æ app)
          BID="${BUNDLE_ID_OVERRIDE:-}"
          if [ -z "$BID" ] && [ -f "$PLIST" ]; then
            BID="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' "$PLIST" 2>/dev/null || true)"
            case "$BID" in *"\$(PRODUCT_BUNDLE_IDENTIFIER)"*) BID="";; esac
          fi
          BUNDLE_ID="${BID:-com.Blem.Eridion}"
          echo "BUNDLE_ID=$BUNDLE_ID" >> "$CM_ENV"

          keychain initialize

          decode_to_file() {
            local VAR="$1"; local DEST="$2"; local VAL="${!VAR:-}"
            [ -z "$VAL" ] && return 1
            echo "$VAL" | base64 --decode > "$DEST" 2>/dev/null || \
            echo "$VAL" | base64 -D > "$DEST" 2>/dev/null || \
            printf "%s" "$VAL" > "$DEST"
          }
          validate_profile() { security cms -D -i "$1" > /dev/null 2>&1; }

          # Provisioning profile ‚Üí –≤—ã—Ç–∞—Å–∫–∏–≤–∞–µ–º TEAM_ID –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º bundle id
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          PROV_PATH="$HOME/Library/MobileDevice/Provisioning Profiles/Store.mobileprovision"
          decode_to_file PROVISIONING_PROFILE "$PROV_PATH"
          validate_profile "$PROV_PATH" || { echo "‚ùå Invalid PROVISIONING_PROFILE"; exit 1; }
          TMP_PLIST="$(mktemp)"
          security cms -D -i "$PROV_PATH" > "$TMP_PLIST"
          PROFILE_NAME="$(/usr/libexec/PlistBuddy -c 'Print Name' "$TMP_PLIST")"
          APP_ID_FULL="$(/usr/libexec/PlistBuddy -c 'Print Entitlements:application-identifier' "$TMP_PLIST")"
          TEAM_ID="${APP_ID_FULL%%.*}"
          APP_ID_SUFFIX="${APP_ID_FULL#*.}"
          if [ "$APP_ID_SUFFIX" != "$BUNDLE_ID" ] && [[ "$APP_ID_SUFFIX" != "*" ]]; then
            echo "‚ùå Profile bundle id mismatch: profile='$APP_ID_SUFFIX' vs app='$BUNDLE_ID'"; exit 1
          fi
          echo "PROFILE_NAME=$PROFILE_NAME" >> "$CM_ENV"
          echo "TEAM_ID=$TEAM_ID" >> "$CM_ENV"
          echo "‚úÖ Using profile: $PROFILE_NAME (TEAM $TEAM_ID)"

          # p12 Distribution cert
          TMP_P12="$HOME/cert_env.p12"
          decode_to_file CERTIFICATE_P12 "$TMP_P12"
          keychain add-certificates --certificate "$TMP_P12" --certificate-password "${CERTIFICATE_PASSWORD:-}" || { echo "‚ùå Failed to import p12 (check base64/password)"; exit 1; }
          security find-identity -v -p codesigning | grep -E "Apple (iOS )?Distribution|Apple Distribution" || { echo "‚ùå No Apple Distribution identity in keychain"; exit 1; }

      - name: Force CFBundleIdentifier to match profile (app target)
        script: |
          set -euo pipefail
          IOS_DIR="$CM_BUILD_DIR/$PROJECT_PATH/$UNITY_IOS_DIR"
          PLIST="$IOS_DIR/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $BUNDLE_ID" "$PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :CFBundleIdentifier string $BUNDLE_ID" "$PLIST"
          echo "CFBundleIdentifier (app) = $(/usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' "$PLIST")"

      - name: Archive with xcodebuild (UNSIGNED + link UserNotifications)
        script: |
          set -euo pipefail
          source "$CM_ENV"
          IOS_DIR="$CM_BUILD_DIR/$PROJECT_PATH/$UNITY_IOS_DIR"
          cd "$IOS_DIR"

          # Detect container
          if [ -d "Unity-iPhone.xcworkspace" ]; then
            CONTAINER_TYPE="workspace"; CONTAINER_PATH="Unity-iPhone.xcworkspace"
          else
            CONTAINER_TYPE="project";   CONTAINER_PATH="${XCODE_PROJECT:-Unity-iPhone.xcodeproj}"
          fi

          ARCH_PATH="$PWD/build/ios/xcarchive/Unity-iPhone.xcarchive"
          mkdir -p "$(dirname "$ARCH_PATH")"
          echo "üì¶ Archiving WITHOUT code signing‚Ä¶"
          XCB_LOG="$PWD/xcodebuild-archive.log"
          BASE_ARGS=( -scheme "$XCODE_SCHEME" -configuration Release -destination "generic/platform=iOS" -archivePath "$ARCH_PATH" archive )
          # –í–ê–ñ–ù–û: –ù–ï –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º PRODUCT_BUNDLE_IDENTIFIER –≥–ª–æ–±–∞–ª—å–Ω–æ
          OVERRIDES=( DEVELOPMENT_TEAM="$TEAM_ID" CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO OTHER_LDFLAGS='$(inherited) -ObjC -framework UserNotifications' )

          if [ "$CONTAINER_TYPE" = "workspace" ]; then
            xcodebuild -workspace "$CONTAINER_PATH" "${BASE_ARGS[@]}" "${OVERRIDES[@]}" > "$XCB_LOG" 2>&1 || { echo "‚ùå archive failed"; tail -n 200 "$XCB_LOG"; exit 65; }
          else
            xcodebuild -project "$CONTAINER_PATH"  "${BASE_ARGS[@]}" "${OVERRIDES[@]}" > "$XCB_LOG" 2>&1 || { echo "‚ùå archive failed"; tail -n 200 "$XCB_LOG"; exit 65; }
          fi

          [ -d "$ARCH_PATH" ] || { echo "‚ùå Archive not found"; tail -n 200 "$XCB_LOG" || true; exit 65; }
          echo "‚úÖ Archive created at $ARCH_PATH"

      - name: Export IPA (automatic signing on export) ‚Äî Fix IDs + file path + fallback
        script: |
          set -euo pipefail
          source "$CM_ENV"
          IOS_DIR="$CM_BUILD_DIR/$PROJECT_PATH/$UNITY_IOS_DIR"
          cd "$IOS_DIR"
          ARCH_PATH="$PWD/build/ios/xcarchive/Unity-iPhone.xcarchive"
          EXPORT_DIR="$PWD/build/ios/ipa"
          mkdir -p "$EXPORT_DIR"

          # === FIX: —É—Å—Ç—Ä–∞–Ω—è–µ–º CFBundleIdentifier Collision –≤–Ω—É—Ç—Ä–∏ –∞—Ä—Ö–∏–≤–∞ ===
          APP_PATH="$(find "$ARCH_PATH/Products/Applications" -maxdepth 1 -type d -name '*.app' | head -n 1)"
          if [ -d "$APP_PATH" ]; then
            HOST_PLIST="$APP_PATH/Info.plist"
            HOST_BID="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' "$HOST_PLIST" 2>/dev/null || echo "")"
            echo "Host bundle id: $HOST_BID"
            # –ø–µ—Ä–µ–±–∏—Ä–∞–µ–º Info.plist —É —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤ –∏ extensions
            while IFS= read -r plist; do
              [ "$plist" = "$HOST_PLIST" ] && continue
              CUR_BID="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' "$plist" 2>/dev/null || echo "")"
              if [ -z "$CUR_BID" ] || [ "$CUR_BID" = "$HOST_BID" ]; then
                base="$(basename "$(dirname "$plist")")"
                suffix="${base%%.*}"
                NEW_BID="${HOST_BID}.${suffix}"
                /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $NEW_BID" "$plist" 2>/dev/null || \
                /usr/libexec/PlistBuddy -c "Add :CFBundleIdentifier string $NEW_BID" "$plist"
                echo "üîß Fixed CFBundleIdentifier for $(dirname "$plist") -> $NEW_BID"
              fi
            done < <(find "$APP_PATH" \( -path "*/Frameworks/*.framework/Info.plist" -o -path "*/PlugIns/*.appex/Info.plist" -o -path "*/Frameworks/*.bundle/Info.plist" \) -type f)
          fi

          # Auto options (Plan B) ‚Äî teamID –≤–∫–ª—é—á—ë–Ω
          cat > export_options_auto.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <plist version="1.0"><dict>
            <key>method</key><string>app-store-connect</string>
            <key>signingStyle</key><string>automatic</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>destination</key><string>export</string>
            <key>compileBitcode</key><false/>
            <key>manageAppVersionAndBuildNumber</key><false/>
          </dict></plist>
          EOF

          # Manual options (Plan A fallback) ‚Äî teamID –≤–∫–ª—é—á—ë–Ω
          cat > export_options_manual.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <plist version="1.0"><dict>
            <key>method</key><string>app-store-connect</string>
            <key>signingStyle</key><string>manual</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key><string>${PROFILE_NAME}</string>
            </dict>
            <key>signingCertificate</key><string>Apple Distribution</string>
            <key>destination</key><string>export</string>
            <key>compileBitcode</key><false/>
            <key>manageAppVersionAndBuildNumber</key><false/>
          </dict></plist>
          EOF

          # === –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï .p8 –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ raw/base64/\n) ===
          KEYS_DIR="$PWD/asc_keys"
          mkdir -p "$KEYS_DIR"
          AC_P8="$KEYS_DIR/AuthKey_${APP_STORE_CONNECT_KEY_IDENTIFIER}.p8"
          rm -f "$AC_P8" "$AC_P8.tmp" || true

          # 1) –ø—Ä–æ–±—É–µ–º –∫–∞–∫ base64
          if echo "$APP_STORE_CONNECT_PRIVATE_KEY" | base64 --decode > "$AC_P8.tmp" 2>/dev/null; then
            :
          else
            # 2) –∏–Ω–∞—á–µ raw: –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º \n –≤ —Ä–µ–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–¥—ã —Å—Ç—Ä–æ–∫
            printf "%s" "$APP_STORE_CONNECT_PRIVATE_KEY" | perl -pe 's/\\n/\n/g' > "$AC_P8.tmp"
          fi

          # –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–µ—Ä–µ–≤–æ–¥ —Å—Ç—Ä–æ–∫
          perl -pe 's/\r\n/\n/g' -i "$AC_P8.tmp"

          # –ø—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ PEM
          if ! grep -q -- '-----BEGIN PRIVATE KEY-----' "$AC_P8.tmp"; then
            echo "‚ùå –ù–µ—Ç BEGIN PRIVATE KEY"; exit 1
          fi
          if ! grep -q -- '-----END PRIVATE KEY-----' "$AC_P8.tmp"; then
            echo "‚ùå –ù–µ—Ç END PRIVATE KEY"; exit 1
          fi

          # –≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–ª—é—á
          if ! openssl pkey -in "$AC_P8.tmp" -noout >/dev/null 2>&1; then
            echo "‚ùå OpenSSL –Ω–µ —Å–º–æ–≥ —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å .p8 ‚Äî –ø—Ä–æ–≤–µ—Ä—å APP_STORE_CONNECT_PRIVATE_KEY"
            exit 1
          fi

          mv "$AC_P8.tmp" "$AC_P8"
          chmod 600 "$AC_P8"
          echo "‚úÖ ASC key OK: $(wc -c < "$AC_P8") bytes at $AC_P8"

          # === –≠–∫—Å–ø–æ—Ä—Ç: —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ–ø–æ–¥–ø–∏—Å—å (—É–∫–∞–∑—ã–≤–∞–µ–º –ü–£–¢–¨ –ö –§–ê–ô–õ–£) ===
          echo "üì¶ Exporting & signing IPA (automatic, file path)‚Ä¶"
          if xcodebuild -exportArchive \
              -archivePath "$ARCH_PATH" \
              -exportOptionsPlist export_options_auto.plist \
              -exportPath "$EXPORT_DIR" \
              -allowProvisioningUpdates \
              -authenticationKeyPath "$AC_P8" \
              -authenticationKeyID "$APP_STORE_CONNECT_KEY_IDENTIFIER" \
              -authenticationKeyIssuerID "$APP_STORE_CONNECT_ISSUER_ID" \
              > "$PWD/xcodebuild-export-auto.log" 2>&1; then
            echo "‚úÖ Automatic export succeeded"
          else
            echo "‚ö†Ô∏è Automatic export failed ‚Äî fallback to manual‚Ä¶"
            tail -n 80 "$PWD/xcodebuild-export-auto.log" || true

            if xcodebuild -exportArchive \
                -archivePath "$ARCH_PATH" \
                -exportOptionsPlist export_options_manual.plist \
                -exportPath "$EXPORT_DIR" \
                > "$PWD/xcodebuild-export-manual.log" 2>&1; then
              echo "‚úÖ Manual export succeeded (fallback)"
            else
              echo "‚ùå export failed (both automatic and manual)"
              tail -n 120 "$PWD/xcodebuild-export-manual.log" || true
              exit 65
            fi
          fi

          IPA_PATH="$(find "$EXPORT_DIR" -maxdepth 1 -name '*.ipa' | head -n 1)"
          [ -f "$IPA_PATH" ] || { echo "‚ùå IPA not created"; exit 1; }
          echo "IPA_PATH=$IPA_PATH" >> "$CM_ENV"
          echo "‚úÖ IPA created: $IPA_PATH"

      - name: Upload to App Store
        script: |
          set -euo pipefail
          source "$CM_ENV"
          python3 -m pip install --quiet --user codemagic-cli-tools
          USER_BIN="$(python3 - <<'PY'
          import site, os; print(os.path.join(site.USER_BASE, "bin"))
          PY
          )"
          [ -d "$USER_BIN" ] && export PATH="$USER_BIN:$PATH"
          [ -n "${IPA_PATH:-}" ] || { echo "‚ùå IPA_PATH is empty"; exit 1; }

          # –ü–µ—Ä–µ–¥–∞—ë–º –≤ CLI —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–ª—é—á–∞: —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å base64, –∏–Ω–∞—á–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å
          if echo "$APP_STORE_CONNECT_PRIVATE_KEY" | base64 --decode > /tmp/asc.p8 2>/dev/null; then
            ASC_PK_CONTENT="$(cat /tmp/asc.p8)"
          else
            ASC_PK_CONTENT="$APP_STORE_CONNECT_PRIVATE_KEY"
          fi

          echo "üöÄ Uploading .ipa to App Store‚Ä¶"
          app-store-connect publish \
            --issuer-id "${APP_STORE_CONNECT_ISSUER_ID?}" \
            --key-id "${APP_STORE_CONNECT_KEY_IDENTIFIER?}" \
            --private-key "${ASC_PK_CONTENT?}" \
            --path "$IPA_PATH"

      - name: Cleanup keychain
        script: |
          set -euo pipefail
          keychain use-login
          keychain delete
          echo "‚úÖ Temp keychain removed."

      - name: Return Unity License
        script: |
          set -euo pipefail
          source "$CM_ENV"
          "$UNITY_BIN" -batchmode -quit -returnlicense || true
          echo "üîì License returned"

    artifacts:
      - "**/*.ipa"
      - $HOME/Library/Developer/Xcode/DerivedData/**/Build/**/*.dSYM
